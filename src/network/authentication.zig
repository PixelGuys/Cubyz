const std = @import("std");

const main = @import("main");
const BinaryWriter = main.utils.BinaryWriter;
const BinaryReader = main.utils.BinaryReader;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const ZonElement = main.ZonElement;

var wordlist: ?[2048][]const u8 = null;

fn wordToIndex(word: []const u8) ?u11 {
	if (wordlist == null) return null;
	for (wordlist.?, 0..) |other, i| {
		if (std.mem.eql(u8, word, other)) {
			return @intCast(i);
		}
	}
	return null;
}

pub fn init() void {
	const wordlistString = main.files.cwd().read(main.globalArena, "assets/cubyz/wordlist") catch |err| {
		std.log.err("Got error while reading word list: {s}", .{@errorName(err)});
		return;
	};
	var splitIterator = std.mem.splitScalar(u8, wordlistString, '\n');
	wordlist = @splat(&.{});
	var i: usize = 0;
	while (splitIterator.next()) |word| {
		wordlist.?[i] = std.mem.trim(u8, word, &std.ascii.whitespace);
		i += 1;
	}
}

pub const KeyTypeEnum = enum(u8) {
	ed25519 = 0,
	ecdsaP256Sha256 = 1,
	mldsa44 = 2,

	pub fn getAlgorithmType(self: KeyTypeEnum) type {
		return switch (self) {
			.ed25519 => std.crypto.sign.Ed25519,
			.ecdsaP256Sha256 => std.crypto.sign.ecdsa.EcdsaP256Sha256,
			.mldsa44 => std.crypto.sign.mldsa.MLDSA44,
		};
	}
};

pub const KeyCollection = struct { // Provides multiple methods to allow server hosts to react when one of the methods is compromised
	const Storage = struct {
		pub var ed25519: std.crypto.sign.Ed25519.KeyPair = undefined;
		pub var ecdsaP256Sha256: std.crypto.sign.ecdsa.EcdsaP256Sha256.KeyPair = undefined;
		pub var mldsa44: std.crypto.sign.mldsa.MLDSA44.KeyPair = undefined;
	};

	pub fn init(seedPhrase: SeedPhrase) void {
		// These are used to salt the the seed phrase for each of the keys so we get unrelated keys in case one of them gets compromised.
		// They were generated by the keyboard mashing RNG
		const keySalts = [_][]const u8{
			"n59zw0qz53q05b73q9a50vmso",
			"4t7z3592a09p85z4piotfh7z",
			"u89564epogz1qi9up5zc94309",
		};
		inline for (comptime std.meta.declarations(Storage), 0..) |decl, i| {
			const hashableString = std.mem.concat(main.stackAllocator.allocator, u8, &.{seedPhrase.text, keySalts[i]}) catch unreachable;
			defer main.stackAllocator.free(hashableString);
			defer @memset(hashableString, 0);

			var hashedResult: [64]u8 = undefined;

			for (0..2048) |j| {
				const input = if (j == 0) hashableString else &hashedResult;
				var out: [64]u8 = undefined;
				std.crypto.hash.sha2.Sha512.hash(input, &out, .{});
				hashedResult = out;
			}

			const functionType = @TypeOf(@TypeOf(@field(Storage, decl.name)).generateDeterministic);
			const seed = hashedResult[0..@sizeOf(@typeInfo(functionType).@"fn".params[0].type.?)].*;

			@field(Storage, decl.name) = @TypeOf(@field(Storage, decl.name)).generateDeterministic(seed) catch @panic("Failed to generate key pair for " ++ decl.name);
		}
	}

	pub fn getPublicKeys(allocator: NeverFailingAllocator) ZonElement {
		const result = ZonElement.initObject(allocator);
		inline for (comptime std.meta.declarations(Storage)) |decl| {
			// TODO: Unify function declarations upstream and link PR
			const bytes = if (@hasDecl(@TypeOf(@field(Storage, decl.name).public_key), "toBytes"))
				@field(Storage, decl.name).public_key.toBytes()
			else
				@field(Storage, decl.name).public_key.toUncompressedSec1();
			var base64: [std.base64.standard.Encoder.calcSize(bytes.len)]u8 = undefined;
			result.putOwnedString(decl.name, std.base64.standard.Encoder.encode(&base64, &bytes));
		}
		return result;
	}

	pub fn sign(writer: *BinaryWriter, typ: KeyTypeEnum, message: []const u8) void {
		switch (typ) {
			inline else => |_typ| {
				const AlgorithmType = _typ.getAlgorithmType();
				const randomBytes = std.crypto.random.array(u8, AlgorithmType.noise_length);
				const signature = @field(Storage, @tagName(_typ)).sign(message, randomBytes) catch |err| {
					std.debug.panic("Failed to sign message with error {s}. Maybe try reconnecting, if the error persists, I'd suggest creating a new account", .{@errorName(err)});
				};
				writer.writeSlice(&signature.toBytes());
			},
		}
	}
};

pub const PublicKey = union(KeyTypeEnum) {
	ed25519: std.crypto.sign.Ed25519.PublicKey,
	ecdsaP256Sha256: std.crypto.sign.ecdsa.EcdsaP256Sha256.PublicKey,
	mldsa44: std.crypto.sign.mldsa.MLDSA44.PublicKey,

	pub fn initFromBase64(base64: []const u8, typ: KeyTypeEnum) !PublicKey {
		switch (typ) {
			inline else => |_typ| {
				const KeyType = @TypeOf(@field(KeyCollection.Storage, @tagName(_typ)).public_key);
				const length = if (@hasDecl(KeyType, "fromBytes")) KeyType.encoded_length else KeyType.uncompressed_sec1_encoded_length;
				var bytes: [length]u8 = undefined;
				try std.base64.standard.Decoder.decode(&bytes, base64);
				if (@hasDecl(KeyType, "fromBytes")) {
					return @unionInit(PublicKey, @tagName(_typ), try KeyType.fromBytes(bytes));
				} else {
					return @unionInit(PublicKey, @tagName(_typ), try KeyType.fromSec1(&bytes));
				}
			},
		}
	}

	pub fn verifySignature(self: PublicKey, reader: *BinaryReader, message: []const u8) !void {
		switch (@as(KeyTypeEnum, self)) {
			inline else => |tag| {
				const AlgorithmType = tag.getAlgorithmType();
				const signature: error{InvalidEncoding}!AlgorithmType.Signature = AlgorithmType.Signature.fromBytes((try reader.readSlice(AlgorithmType.Signature.encoded_length))[0..AlgorithmType.Signature.encoded_length].*);
				try (try signature).verify(message, @field(self, @tagName(tag)));
			},
		}
	}
};

pub const SeedPhrase = struct {
	text: []u8,

	pub fn initFromUserInput(text: []const u8, failureText: *main.List(u8)) SeedPhrase {
		var result: main.ListUnmanaged(u8) = .initCapacity(main.stackAllocator, text.len);
		defer result.deinit(main.stackAllocator);
		defer std.crypto.secureZero(u8, result.items);

		const trimmed = std.mem.trim(u8, text, &std.ascii.whitespace);

		for (trimmed) |char| {
			if (std.ascii.isAlphabetic(char)) {
				result.appendAssumeCapacity(std.ascii.toLower(char));
			} else if (std.ascii.isWhitespace(char)) {
				if (result.items[result.items.len - 1] != ' ') {
					result.appendAssumeCapacity(' ');
				}
			} else {
				failureText.print("Seed phrase contains invalid character '{c}', only ASCII letters and whitespaces are allowed.\n", .{char});
			}
		}
		if (result.items.len == 0) {
			failureText.print("Seed phrase is empty.\n", .{});
			return .{.text = ""};
		}
		if (result.items[result.items.len - 1] == ' ') _ = result.pop();

		var split = std.mem.splitScalar(u8, result.items, ' ');
		var wordCount: usize = 0;
		var bits: [21]u8 = @splat(0);
		defer std.crypto.secureZero(u8, &bits);
		var failedWordlist: bool = false;
		while (split.next()) |word| {
			wordCount += 1;
			if (wordToIndex(word)) |wordIndex| {
				if (wordCount <= 15) {
					const bitIndex = (wordCount - 1)*11;
					const byteIndex = bitIndex/8;
					const containingRegion: usize = @as(usize, wordIndex) << @intCast(8*3 - 11 - bitIndex%8);

					bits[byteIndex] |= @truncate(containingRegion >> 16);
					bits[byteIndex + 1] |= @truncate(containingRegion >> 8);
					if (byteIndex + 2 < bits.len) bits[byteIndex + 2] |= @truncate(containingRegion);
				}
			} else {
				failureText.print("The {}{s} word of the seed phrase is not a part of the wordlist.\n", .{wordCount, if (wordCount == 1) "st" else if (wordCount == 2) "nd" else if (wordCount == 3) "rd" else "th"});
				failedWordlist = true;
			}
		}

		if (wordCount != 15) {
			failureText.print("The seed phrase contains an invalid number of words. Should be 15.\n", .{});
			failedWordlist = true;
		}

		if (!failedWordlist) {
			var sha256Result: [32]u8 = undefined;
			defer std.crypto.secureZero(u8, &sha256Result);
			std.crypto.hash.sha2.Sha256.hash(bits[0..20], &sha256Result, .{});
			if (sha256Result[0] >> 3 != bits[20] >> 3) {
				failureText.print("The seed phrase has an incorrect checksum.\n", .{});
			}
		}

		// TODO: Checksum check

		return .{
			.text = main.globalAllocator.dupe(u8, result.items),
		};
	}

	pub fn initRandomly() SeedPhrase {
		if (wordlist == null) @panic("Cannot generate new Account without a valid wordlist.");
		var bits: [21]u8 = undefined;
		defer std.crypto.secureZero(u8, &bits);
		std.crypto.random.bytes(bits[0..20]);
		var sha256Result: [32]u8 = undefined;
		defer std.crypto.secureZero(u8, &sha256Result);
		std.crypto.hash.sha2.Sha256.hash(bits[0..20], &sha256Result, .{});
		bits[20] = sha256Result[0];

		var result: main.ListUnmanaged(u8) = .{};
		defer result.deinit(main.stackAllocator);
		defer std.crypto.secureZero(u8, result.items);

		for (0..15) |i| {
			const bitIndex = i*11;
			const byteIndex = bitIndex/8;

			const containingRegion = @as(usize, bits[byteIndex]) << 16 | @as(usize, bits[byteIndex + 1]) << 8 | if (byteIndex + 2 < bits.len) bits[byteIndex + 2] else 0;
			const wordIndex: u11 = @truncate(containingRegion >> @intCast(8*3 - 11 - bitIndex%8));

			if (i != 0) result.append(main.stackAllocator, ' ');
			result.appendSlice(main.stackAllocator, wordlist.?[wordIndex]);
		}

		return .{
			.text = main.globalAllocator.dupe(u8, result.items),
		};
	}

	pub fn deinit(self: SeedPhrase) void {
		std.crypto.secureZero(u8, self.text);
		main.globalAllocator.free(self.text);
	}
};

const EncodingType = enum { none, argon2_aes_gcm };

pub const PasswordEncodedSeedPhrase = struct {
	typ: EncodingType,
	salt: []u8,
	nonce: []u8,
	data: []u8,
	authenticationTag: []u8,

	pub const empty: PasswordEncodedSeedPhrase = .{.typ = .none, .salt = &.{}, .nonce = &.{}, .data = &.{}, .authenticationTag = &.{}};

	pub fn initFromPassword(allocator: NeverFailingAllocator, seedPhrase: SeedPhrase, password: []const u8) PasswordEncodedSeedPhrase {
		var salt: [32]u8 = std.crypto.random.array(u8, 32);
		const saltBase64 = allocator.alloc(u8, std.base64.standard.Encoder.calcSize(salt.len));
		std.debug.assert(std.base64.standard.Encoder.encode(saltBase64, &salt).len == saltBase64.len);

		var key: [32]u8 = undefined;
		defer std.crypto.secureZero(u8, &key);
		keyFromPassword(.argon2_aes_gcm, saltBase64, password, &key);

		const encryptedBuffer = allocator.alloc(u8, seedPhrase.text.len);
		var authenticationTag: [std.crypto.aead.aes_gcm.Aes256Gcm.tag_length]u8 = undefined;
		const nonce = std.crypto.random.array(u8, std.crypto.aead.aes_gcm.Aes256Gcm.nonce_length);
		std.crypto.aead.aes_gcm.Aes256Gcm.encrypt(encryptedBuffer, &authenticationTag, seedPhrase.text, &.{}, nonce, key);

		return .{
			.typ = .argon2_aes_gcm,
			.salt = saltBase64,
			.data = encryptedBuffer,
			.nonce = allocator.dupe(u8, &nonce),
			.authenticationTag = allocator.dupe(u8, &authenticationTag),
		};
	}

	pub fn initUnencoded(allocator: NeverFailingAllocator, seedPhrase: SeedPhrase) PasswordEncodedSeedPhrase {
		return .{
			.typ = .none,
			.salt = &.{},
			.nonce = &.{},
			.data = allocator.dupe(u8, seedPhrase.text),
			.authenticationTag = &.{},
		};
	}

	pub fn deinit(self: PasswordEncodedSeedPhrase, allocator: NeverFailingAllocator) void {
		allocator.free(self.salt);
		allocator.free(self.data);
		allocator.free(self.nonce);
		allocator.free(self.authenticationTag);
	}

	pub fn decryptFromPassword(self: PasswordEncodedSeedPhrase, password: []const u8, failureText: *main.List(u8)) !SeedPhrase {
		if (self.typ == .none) {
			return SeedPhrase.initFromUserInput(self.data, failureText);
		}
		var key: [32]u8 = undefined;
		defer std.crypto.secureZero(u8, &key);
		keyFromPassword(self.typ, self.salt, password, &key);

		switch (self.typ) {
			.none => unreachable,
			.argon2_aes_gcm => {
				if (self.authenticationTag.len != std.crypto.aead.aes_gcm.Aes256Gcm.tag_length) return error.Invalid;
				if (self.nonce.len != std.crypto.aead.aes_gcm.Aes256Gcm.nonce_length) return error.Invalid;
				const authenticationTag = self.authenticationTag[0..std.crypto.aead.aes_gcm.Aes256Gcm.tag_length];
				const nonce = self.nonce[0..std.crypto.aead.aes_gcm.Aes256Gcm.nonce_length];
				const decryptedBuffer = main.stackAllocator.alloc(u8, self.data.len);
				defer main.stackAllocator.free(decryptedBuffer);
				defer std.crypto.secureZero(u8, decryptedBuffer);
				try std.crypto.aead.aes_gcm.Aes256Gcm.decrypt(decryptedBuffer, self.data, authenticationTag.*, &.{}, nonce.*, key);
				return SeedPhrase.initFromUserInput(decryptedBuffer, failureText);
			},
		}
	}

	fn keyFromPassword(typ: EncodingType, salt: []const u8, password: []const u8, key: *[32]u8) void {
		switch (typ) {
			.none => unreachable,
			.argon2_aes_gcm => {
				std.crypto.pwhash.argon2.kdf(main.globalAllocator.allocator, key, password, salt, .{
					.t = 10,
					.m = 32000,
					.p = 1,
				}, .argon2id) catch unreachable;
			},
		}
	}

	pub fn fromZon(allocator: NeverFailingAllocator, zon: ZonElement) !PasswordEncodedSeedPhrase {
		if (zon == .null) return .empty;
		var self: PasswordEncodedSeedPhrase = undefined;

		self.typ = std.meta.stringToEnum(EncodingType, zon.get(?[]const u8, "type", null) orelse return error.Invalid) orelse return error.Invalid;
		self.salt = allocator.dupe(u8, zon.get([]const u8, "salt", ""));
		errdefer allocator.free(self.salt);
		if (self.salt.len < 32 and self.typ != .none) return error.Invalid;

		const base64EncodedData = zon.get([]const u8, "data", "");
		self.data = allocator.alloc(u8, try std.base64.standard.Decoder.calcSizeForSlice(base64EncodedData));
		errdefer allocator.free(self.data);
		try std.base64.standard.Decoder.decode(self.data, base64EncodedData);
		if (self.data.len == 0 and self.typ != .none) return error.Invalid;

		const base64EncodedTag = zon.get([]const u8, "authenticationTag", "");
		self.authenticationTag = allocator.alloc(u8, try std.base64.standard.Decoder.calcSizeForSlice(base64EncodedTag));
		errdefer allocator.free(self.authenticationTag);
		try std.base64.standard.Decoder.decode(self.authenticationTag, base64EncodedTag);
		if (self.authenticationTag.len == 0 and self.typ != .none) return error.Invalid;

		const base64EncodedNonce = zon.get([]const u8, "nonce", "");
		self.nonce = allocator.alloc(u8, try std.base64.standard.Decoder.calcSizeForSlice(base64EncodedNonce));
		errdefer allocator.free(self.nonce);
		try std.base64.standard.Decoder.decode(self.nonce, base64EncodedNonce);
		if (self.nonce.len == 0 and self.typ != .none) return error.Invalid;

		return self;
	}

	pub fn toZon(self: PasswordEncodedSeedPhrase, allocator: NeverFailingAllocator) ZonElement {
		const zon = ZonElement.initObject(allocator);
		zon.put("type", @tagName(self.typ));
		zon.putOwnedString("salt", self.salt);

		const base64EncodedData = main.stackAllocator.alloc(u8, std.base64.standard.Encoder.calcSize(self.data.len));
		defer main.stackAllocator.free(base64EncodedData);
		zon.putOwnedString("data", std.base64.standard.Encoder.encode(base64EncodedData, self.data));

		const base64EncodedTag = main.stackAllocator.alloc(u8, std.base64.standard.Encoder.calcSize(self.authenticationTag.len));
		defer main.stackAllocator.free(base64EncodedTag);
		zon.putOwnedString("authenticationTag", std.base64.standard.Encoder.encode(base64EncodedTag, self.authenticationTag));

		const base64EncodedNonce = main.stackAllocator.alloc(u8, std.base64.standard.Encoder.calcSize(self.nonce.len));
		defer main.stackAllocator.free(base64EncodedNonce);
		zon.putOwnedString("nonce", std.base64.standard.Encoder.encode(base64EncodedNonce, self.nonce));

		return zon;
	}
};

pub fn secureZero(comptime T: type, s: []volatile T) void { // TODO: Remove after zig#31197
	@memset(s, std.mem.zeroes(T));
}
