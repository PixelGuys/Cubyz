const std = @import("std");

const main = @import("main");
const BinaryWriter = main.utils.BinaryWriter;
const BinaryReader = main.utils.BinaryReader;
const NeverFailingAllocator = main.heap.NeverFailingAllocator;
const ZonElement = main.ZonElement;

var wordlist: ?[2048][]const u8 = null;

fn wordToIndex(word: []const u8) ?u11 {
	if (wordlist == null) return null;
	for (wordlist.?, 0..) |other, i| {
		if (std.mem.eql(u8, word, other)) {
			return @intCast(i);
		}
	}
	return null;
}

pub fn init() void {
	const wordlistString = main.files.cwd().read(main.globalArena, "assets/cubyz/wordlist") catch |err| {
		std.log.err("Got error while reading word list: {s}", .{@errorName(err)});
		return;
	};
	var splitIterator = std.mem.splitScalar(u8, wordlistString, '\n');
	wordlist = @splat(&.{});
	var i: usize = 0;
	while (splitIterator.next()) |word| {
		wordlist.?[i] = word;
		i += 1;
	}
}

pub const KeyTypeEnum = enum(u8) {
	ed25519 = 0,
	ecdsaP256Sha256 = 1,
	mldsa44 = 2,

	pub fn getAlgorithmType(self: KeyTypeEnum) type {
		return switch (self) {
			.ed25519 => std.crypto.sign.Ed25519,
			.ecdsaP256Sha256 => std.crypto.sign.ecdsa.EcdsaP256Sha256,
			.mldsa44 => std.crypto.sign.mldsa.MLDSA44,
		};
	}
};

pub const KeyCollection = struct { // Provides multiple methods to allow server hosts to react when one of the methods is compromised
	const Storage = struct {
		pub var ed25519: std.crypto.sign.Ed25519.KeyPair = undefined;
		pub var ecdsaP256Sha256: std.crypto.sign.ecdsa.EcdsaP256Sha256.KeyPair = undefined;
		pub var mldsa44: std.crypto.sign.mldsa.MLDSA44.KeyPair = undefined;
	};

	pub fn init(seedPhrase: SeedPhrase) void {
		// These are used to salt the the seed phrase for each of the keys so we get unrelated keys in case one of them gets compromised.
		// They were generated by the keyboard mashing RNG
		const keySalts = [_][]const u8{
			"n59zw0qz53q05b73q9a50vmso",
			"4t7z3592a09p85z4piotfh7z",
			"u89564epogz1qi9up5zc94309",
		};
		inline for (comptime std.meta.declarations(Storage), 0..) |decl, i| {
			const hashableString = std.mem.concat(main.stackAllocator.allocator, u8, &.{seedPhrase.text, keySalts[i]}) catch unreachable;
			defer main.stackAllocator.free(hashableString);
			defer @memset(hashableString, 0);

			var hashedResult: [64]u8 = undefined;

			for (0..2048) |j| {
				const input = if (j == 0) hashableString else &hashedResult;
				var out: [64]u8 = undefined;
				std.crypto.hash.sha2.Sha512.hash(input, &out, .{});
				hashedResult = out;
			}

			const functionType = @TypeOf(@TypeOf(@field(Storage, decl.name)).generateDeterministic);
			const seed = hashedResult[0..@sizeOf(@typeInfo(functionType).@"fn".params[0].type.?)].*;

			@field(Storage, decl.name) = @TypeOf(@field(Storage, decl.name)).generateDeterministic(seed) catch @panic("Failed to generate key pair for " ++ decl.name);
		}
	}

	pub fn getPublicKeys(allocator: NeverFailingAllocator) ZonElement {
		const result = ZonElement.initObject(allocator);
		inline for (comptime std.meta.declarations(Storage)) |decl| {
			// TODO: Unify function declarations upstream and link PR
			const bytes = if (@hasDecl(@TypeOf(@field(Storage, decl.name).public_key), "toBytes"))
				@field(Storage, decl.name).public_key.toBytes()
			else
				@field(Storage, decl.name).public_key.toUncompressedSec1();
			var base64: [std.base64.standard.Encoder.calcSize(bytes.len)]u8 = undefined;
			result.putOwnedString(decl.name, std.base64.standard.Encoder.encode(&base64, &bytes));
		}
		return result;
	}

	pub fn sign(writer: *BinaryWriter, typ: KeyTypeEnum, message: []const u8) void {
		switch (typ) {
			inline else => |_typ| {
				const AlgorithmType = _typ.getAlgorithmType();
				const randomBytes = std.crypto.random.array(u8, AlgorithmType.noise_length);
				const signature = @field(Storage, @tagName(_typ)).sign(message, randomBytes) catch |err| {
					std.debug.panic("Failed to sign message with error {s}. Maybe try reconnecting, if the error persists, I'd suggest creating a new account", .{@errorName(err)});
				};
				writer.writeSlice(&signature.toBytes());
			},
		}
	}
};

pub const PublicKey = union(KeyTypeEnum) {
	ed25519: std.crypto.sign.Ed25519.PublicKey,
	ecdsaP256Sha256: std.crypto.sign.ecdsa.EcdsaP256Sha256.PublicKey,
	mldsa44: std.crypto.sign.mldsa.MLDSA44.PublicKey,

	pub fn initFromBase64(base64: []const u8, typ: KeyTypeEnum) !PublicKey {
		switch (typ) {
			inline else => |_typ| {
				const KeyType = @TypeOf(@field(KeyCollection.Storage, @tagName(_typ)).public_key);
				// TODO: Unify function declarations upstream and link PR
				const length = if (@hasDecl(KeyType, "fromBytes")) KeyType.encoded_length else KeyType.uncompressed_sec1_encoded_length;
				var bytes: [length]u8 = undefined;
				try std.base64.standard.Decoder.decode(&bytes, base64);
				// TODO: Unify function declarations upstream and link PR
				if (@hasDecl(KeyType, "fromBytes")) {
					return @unionInit(PublicKey, @tagName(_typ), try KeyType.fromBytes(bytes));
				} else {
					return @unionInit(PublicKey, @tagName(_typ), try KeyType.fromSec1(&bytes));
				}
			},
		}
	}

	pub fn verifySignature(self: PublicKey, reader: *BinaryReader, message: []const u8) !void {
		switch (@as(KeyTypeEnum, self)) {
			inline else => |tag| {
				const AlgorithmType = tag.getAlgorithmType();
				// TODO: Unify function signatures upstream and link PR
				const signature: error{InvalidEncoding}!AlgorithmType.Signature = AlgorithmType.Signature.fromBytes((try reader.readSlice(AlgorithmType.Signature.encoded_length))[0..AlgorithmType.Signature.encoded_length].*);
				try (try signature).verify(message, @field(self, @tagName(tag)));
			},
		}
	}
};

pub const SeedPhrase = struct {
	text: []u8,

	pub fn initFromUserInput(text: []const u8, failureText: *main.List(u8)) SeedPhrase {
		var result: main.ListUnmanaged(u8) = .initCapacity(main.stackAllocator, text.len);
		defer result.deinit(main.stackAllocator);
		defer @memset(result.items, 0);

		const trimmed = std.mem.trim(u8, text, &std.ascii.whitespace);

		for (trimmed) |char| {
			if (std.ascii.isAlphabetic(char)) {
				result.appendAssumeCapacity(std.ascii.toLower(char));
			} else if (std.ascii.isWhitespace(char)) {
				if (result.items[result.items.len - 1] != ' ') {
					result.appendAssumeCapacity(' ');
				}
			} else {
				failureText.print("Seed phrase contains invalid character '{c}', only ASCII letters and whitespaces are allowed\n", .{char});
			}
		}
		if (result.items[result.items.len - 1] == ' ') _ = result.pop();

		var split = std.mem.splitScalar(u8, result.items, ' ');
		var wordCount: usize = 0;
		var bits: [21]u8 = @splat(0);
		defer @memset(&bits, 0);
		var failedWordlist: bool = false;
		while (split.next()) |word| {
			wordCount += 1;
			if (wordToIndex(word)) |wordIndex| {
				if (wordCount <= 15) {
					const bitIndex = (wordCount - 1)*11;
					const byteIndex = bitIndex/8;
					const containingRegion: usize = @as(usize, wordIndex) << @intCast(8*3 - 11 - bitIndex%8);

					bits[byteIndex] |= @truncate(containingRegion >> 16);
					bits[byteIndex + 1] |= @truncate(containingRegion >> 8);
					if (byteIndex + 2 < bits.len) bits[byteIndex + 2] |= @truncate(containingRegion);
				}
			} else {
				failureText.print("The {}{s} word of the seed phrase is not a part of the wordlist.\n", .{wordCount, if (wordCount == 1) "st" else if (wordCount == 2) "nd" else if (wordCount == 3) "rd" else "th"});
				failedWordlist = true;
			}
		}

		if (wordCount != 15) {
			failureText.print("The seed phrase contains an invalid number of words. Should be 15.\n", .{});
			failedWordlist = true;
		}

		if (!failedWordlist) {
			var sha256Result: [32]u8 = undefined;
			defer @memset(&sha256Result, 0);
			std.crypto.hash.sha2.Sha256.hash(bits[0..20], &sha256Result, .{});
			if (sha256Result[0] >> 3 != bits[20] >> 3) {
				failureText.print("The seed phrase has an incorrect checksum.\n", .{});
			}
		}

		// TODO: Checksum check

		return .{
			.text = main.globalAllocator.dupe(u8, result.items),
		};
	}

	pub fn initRandomly() SeedPhrase {
		if (wordlist == null) @panic("Cannot generate new Account without a valid wordlist.");
		var bits: [21]u8 = undefined;
		defer @memset(&bits, 0);
		std.crypto.random.bytes(bits[0..20]);
		var sha256Result: [32]u8 = undefined;
		defer @memset(&sha256Result, 0);
		std.crypto.hash.sha2.Sha256.hash(bits[0..20], &sha256Result, .{});
		bits[20] = sha256Result[0];

		var result: main.ListUnmanaged(u8) = .{};
		defer result.deinit(main.stackAllocator);
		defer @memset(result.items, 0);

		for (0..15) |i| {
			const bitIndex = i*11;
			const byteIndex = bitIndex/8;

			const containingRegion = @as(usize, bits[byteIndex]) << 16 | @as(usize, bits[byteIndex + 1]) << 8 | if (byteIndex + 2 < bits.len) bits[byteIndex + 2] else 0;
			const wordIndex: u11 = @truncate(containingRegion >> @intCast(8*3 - 11 - bitIndex%8));

			if (i != 0) result.append(main.stackAllocator, ' ');
			result.appendSlice(main.stackAllocator, wordlist.?[wordIndex]);
		}

		return .{
			.text = main.globalAllocator.dupe(u8, result.items),
		};
	}

	pub fn deinit(self: SeedPhrase) void {
		@memset(self.text, 0);
		main.globalAllocator.free(self.text);
	}
};
